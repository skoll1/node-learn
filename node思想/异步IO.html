<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<ul>
		<li>
			node出现之前，最常用的异步编程场景就是ajax.
		</li>
		<li>
			高级语言屏蔽了异步特性。php中，同步阻塞的写法可以使程序顺着业务逻辑写程序，但是在大规模的网站中，阻塞导致无法更好的并发。
		</li>
		<li>
			异步IO的重要性：
			<ul>
				<li>
					1：在跨网络的结构下，并发是现代编程的标配了，web服务早已不是单台服务器就可以胜任的了。
				</li>
				<li>
					只有后端能够快速响应资源，才能让前端体验变的更好
				</li>
				<li>
					2:资源分配
					<ul>
						<li>单线程同步编程会因为阻塞IO导致硬件资源得不到更好的应用</li>
						<li>
							多线程模型的编程过程中的死锁，状态同步也是个问题
						</li>
						<li>
							node--利用单线程，远离死锁，利用异步IO,力求在单线程上实现资源的高效分配。
						</li>
						<li>
							为了弥补单线程上不能充分利用多核浏览器的缺点，node提供了类似前端web worker的子进程。可以高效的利用cpu和IO.
						</li>
						<li>
							异步IO的提出就是希望IO的调用可以不在阻塞后续的运算，将原有的等待IO的时间分配给其余需要执行的业务。
						</li>
					</ul>
				</li>
			</ul>
		</li>
		<li>
			异步在前端
			<ul>
				<li>
					避免js单线程带来的阻塞。
				</li>
				<li>
					消除UI阻塞的现象。（数据加载的时候）
				</li>
			</ul>
		</li>
		<li>
			node中的异步IO:事件循环（事件生产--消费过程）
			<ul>
				<li>
					异步IO,网络请求等则是事件的生产者，源源不断的为Node提供不同类型的事件，这些事件被传到对应的观察者那里，事件循环则从那些观察者那里取到事件并处理。
				</li>
				<li>
					每一个项目启动的时候，node便创建一个循环，每一个循环的过程就是看里面是否有事件处理，如果有，就取出相关的把事件极其相关的回调函数，如果存在关联的回调函数，就执行他们，然后进行入狭义循环。
				</li>
				<li>
					请求对象：js发起调动到内核执行完IO操作的过渡过程中，出现的一种中间产物。所有的状态都保存在这个对象中，包括送入线程池等待执行以及IO操作完毕后的回调处理。
				</li>
				<li>
					事件循环，请求对象，观察者，io线程池四者构成了Node异步IO模型的基本要素。
				</li>
			</ul>
		</li>
	</ul>
</body>
</html>