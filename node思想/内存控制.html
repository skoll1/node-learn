<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<h1>内存控制</h1>
	<ul>
		<li>
			没有内存管理必要的场景：
			<ul>
				<li>
					网页应用，命令行工具
				</li>
				<li>
					这类场景由于运行时间短，且运行在用户的机器上。即使存在内存使用过多或者内存泄漏，也只会影响到终端用户。
				</li>
				<li>
					由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要
				</li>
			</ul>
		</li>
		<li>
			基于无阻塞，事件驱动下的node服务，具有内存消耗低的特点，非常适合处理海量的请求。内存控制正是海量请求和长时间运行的前提下必须考虑的东西。
		</li>
		<li>
			V8的垃圾回收机制和内存限制（1.4GB,0.7GB）
			<ul>
				<li>
					node在执行上直接受益于V8，可以随着V8的升级享受到更好的性能和好的语言特性，同时也受到一些限制。
				</li>
				<li>
					v8内存上的策略:所有对象分配都是通过堆来进行分配的
					<ul>
						<li>
							限制内存大小的原因
							<ul>
								<li>
									垃圾回收机制，小的垃圾回收很快，1.5G的回收需要1s,这样的时间花销上，应用的性能和响应能力会直线下降，所以必须限制内存。
								</li>
								<li>
									V8是为了浏览器设计的，不可能遇到大量的内存的场景。
								</li>
								<li>
									垃圾回收算法：根据对象生存周期的长短选择不同的算法
									<ul>
										<li>
											新生代的生存空间
										</li>
										<li>
											老生代的生存空间
										</li>
										<li>
											增量标记：早期在垃圾回收的时候采用全停顿，也就是垃圾回收的时候程序会被暂停，对于前端开发来说，没有什么明显的缺点，前端开发使用的内存较小，大多数只是触发新生代垃圾回收，速度快，卡顿几乎感觉不到，但是对于Node程序，使用内存更多，在老年代垃圾回收时，全停顿机会很容易带来明显的程序延迟，因此引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在5ms内，没运行一段时间标记动作，就让js程序执行一会，如此交替，明显的提高了程序流畅性，一定层度上避免了长时间卡顿。
										</li>
									</ul>
								</li>
								<li>
									四个主要的垃圾回收任务
									<ul>
										<li>
											年轻一代的清扫，通常是非常快速的
										</li>
										<li>
											由增量标记执行标记步骤，可以根据步任意长
										</li>
										<li>
											完整的垃圾收集，可能需要很长时间
										</li>
										<li>
											完整的垃圾收集与积极的内存压缩，这可能需要很长的时间，
										</li>
										<li>
											注意：为了在空闲时间执行这些操作，V8将垃圾收集空闲任务发送到调度程序，当空闲任务运行时，他们将提供一个截止日期，v8的垃圾收集空闲时间处理程序将评估该执行那些收集任务，以便减少内存消耗，同时遵守截止日期以避免他们在帧显示之前或输入延迟中的未来冲突
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<h1>node如何高效实用内存：尽量减少垃圾回收，尤其是全堆垃圾回收，如何让垃圾回收机制更高效工作</h1>
	<ul>
		<li>
			V8的垃圾回收机制:
			<ul>
				<li>
					当我们在代码中声明变量并且赋值的时候，所使用的对象的内存就分配在堆中。如果已申请的对空闲内存不够，将继续申请堆内存，知道大小超过限制为止。
				</li>
				<li>
					内存限制可以打破，可以在项目启动的时候指定老生，新生代堆内存的大小。
				</li>
				<li>
					新生代使用复制算法：空间换时间
				</li>
				<li>
					老生代使用的是合并算法（当一个对象经历过复制算法回收还存活，To空间的内存占比超过一定的限制）
				</li>
			</ul>
		</li>
		<li>
			node开发中的内存管理和优化
			<ul>
				<li>
					作用域有关
					<ul>
						<li>
							手动销毁变量:delete可能干扰V8的优化。
						</li>
						<li>
							全局变量，golbal或者不通过var 声明的变量。全局变量直到进程结束才会释放，提前释放有两种方法，delete，重新赋值。
						</li>
						<li>
							闭包:外部作用域可以访问内部作用域变量的方法。
						</li>
					</ul>
				</li>
			</ul>
		</li>
		<li>
			正常js执行的时候，无法立即回收的变量主要是闭包和全局变量，因此要十分小心此类变量的增加。
		</li>
		<li>
			查看进程使用的内存情况，查看操作系统的内存占用。os.totalmem 
		</li>
		<li>node内存只要构成是V8进行分配的部分和node自行分类的部分，受垃圾回收限制的主要是V8的堆内存</li>
	</ul>
	<h1>内存泄漏</h1>
	<ul>
		<li>
			缓存：不要拿内存当缓存。原则上是限定缓存对象的大小，家还是那个完善的过期策略可以防止内存的无限增长。
			<ul>
				<li>
					模块机制：模块的缓存机制，模块是老生代，所以在设计模块的时候，要小心内存泄漏的出现
				</li>
				<li>
					在node 中大量使用缓存：比较好的方法是采取进程外缓存，进程自身不存储状态，外部的缓存软件有着良好的缓存过期策略和自有的内存管理，不影响node性能。
					<ul>
						<li>
							好处
						</li>
						<li>
							将缓存的转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效
						</li>
						<li>
							进程之间可以共享内存
						</li>
					</ul>
				</li>
			</ul>
		</li>
		<li>
			队列消费不及时
			<ul>
				<li>
					消费大于输出
				</li>
			</ul>
		</li>
		<li>
			作用域未释放
		</li>
		<li>
			排除内存泄漏：通过对堆内存进行分析而找到。
		</li>
	</ul>
	<h1>大内存的应用</h1>
	<ul>
		<li>
			stream模块。通过流的方式，代码不会受到V8内存的现值，可以提高程序的健壮性。
		</li>
		<li>
			buffer是操作二进制的对象，不论是字符串还是图片，底层都是二进制数据，因此buffer可以适用于任何类型的文件操作

		</li>
		<li>
			buffer保存的对象是在堆外面，是由c++申请分配的，因此不受V8管理，也不需要被V8垃圾回收，一定程度上节省了V8资源。
		</li>
	</ul>
</body>
</html>