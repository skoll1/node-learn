<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<ul>
		<li>
			在node中，使用openSSL类库作为其内部实现加密和解密处理的基础手段。
		</li>
		<li>
			散列算法：在一段数据进行验证的前提下，将该数据模糊话，或者为一大段数据提供一个验证码。
		</li>
		<li>
			hmac算法：将散列算法和一个密匙结合在一些，以阻止对签名完整性的破坏
			<ul>
				<li>
					Cipher:加密数据
					<ul>
						<li>
							创建cipher对象
							<ul>
								<li>
									crypto.createCipher(1,2)
								</li>
								<li>
									1：加密使用的算法
								</li>
								<li>
									2:加密使用的密码：必须为一个二进制格式的字符串或者一个Buffer对象
								</li>
								<li>
									crypto.createCipheriv(1,2,3)
								</li>
								<li>
									3:加密时使用的初始向量
								</li>
								<li>
									这俩个都返回一个加密对象，在node中，使用分块加密法进行加密，分模块加密法将固定长度的数据块或纯文本数据加密成长度相同的密码块数据
								</li>
							</ul>
						</li>
						<li>
							指定需要被加密的数据
							<ul>
								<li>
									cipher.update(1,2,3)
								</li>
								<li>
									1：需要加密的数据，一个字符串或者buffer.
								</li>
								<li>
									2:被加密数据所需使用的编码格式。
								</li>
								<li>
									3:输出加密数据时使用的编码格式。
								</li>
								<li>
									此时返回一个被加密的数据，可以使用update多次添加需要的数据。
								</li>
								<li>
									与hash以及hmac对象的update不同的是，cipher的update对象返回的是一个被分块的的加密数据，因此块的大小是十分重要的，如果加密码的字节数足够创建一个块，update就返回加密的数据，否则，加密数据将被缓存在cipher对象中。
								</li>
							</ul>
						</li>
						<li>
							返回加密数据
							<ul>
								<li>
									cipher.final(1);
								</li>
								<li>
									1:输出加密数据的编码格式
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					Decipher:解密数据
					<ul>
						<li>
							创建一个解密数据
							<ul>
								<li>
									crypto.createDecipher(1,2)
								</li>
								<li>
									1:解密时使用的算法，该算法必须和加密时候使用的算法一致。
								</li>
								<li>
									2:密码,必须和加密的时候使用的一样。
								</li>
								<li>
									cypto.createDecpiheriv(1,2,3)
								</li>
								<li>
									3:解密时使用的初始向量，必须和加密的时候一样。
								</li>
							</ul>
						</li>
						<li>
							指定需要解密的数据
							<ul>
								<li>
									decipher.update(1,2,3)
								</li>
								<li>
									1:解密数据
								</li>
								<li>
									2:解密数据使用的编码
								</li>
								<li>
									3:输出的时候使用的编码
								</li>
							</ul>
						</li>
						<li>
							输出数据
							<ul>
								<li>
									decipher.final(1)
								</li>
								<li>
									输出解密数据的编码格式
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					Sign:生成签名。私匙的拥有者可以在一段数据被发送前就对该数据进行签名操作，在前面的过程中，将对这段数据执行加密过程，在进过加密之后的数据发送之后，数据的接受者可以通过公匙的使用对改签名解密和验证，以确保这段数据是私匙的拥有者发送出来的原始数据
				</li>
				<li>
					Verify:验证签名
				</li>

			</ul>
		</li>
	</ul>
</body>
</html>