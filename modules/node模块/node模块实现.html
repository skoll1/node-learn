<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<ul>
		<li>
			引入模块步骤
			<ul>
				<li>
					路径分析:根据模块标识符分析
					<ul>
						<li>
							核心模块，fs：在node源代码编译过程中就已经编译为二进制代码了。
						</li>
						<li>
							. .. 开始的相对路径文件模块。
						</li>
						<li>
							/ 绝对路径文件模块
						</li>
						<li>
							非路径形式的文件模块
						</li>
						<li>
							模块路径：node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组
							<ul>
								<li>
									当前文件目录下的node_modules
								</li>
								<li>
									父目录下的node_modules
								</li>
								<li>
									父目录的父目录下的node_modules
								</li>
								<li>
									沿着路径一直上找，直到根目录下的node_modules
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					文件定位：文件扩展名的分析，目录，包的处理。
					<ul>
						<li>
							require()在分析标识符的时候，有可能会出现标识符不包括扩展名的时候。
						</li>
						<li>
							.js .node .json 按照这个次序补充扩展名，依次尝试。
						</li>
						<li>
							需要注意的是，在尝试的时候，需要调用fs模块同步阻塞式的判断文件是否存在。因为node是单线程的，所以这里可能是一个会引发性能问题的地方。所以。如果是.node,.json文件，在传递给require（）的时候最好带上扩展名，会加快一点速度。
						</li>
					</ul>
				</li>
				<li>
					编译执行：在node中，每个模块都是一个对象。都有自己的属性。定位到具体的文件之后，node会新建一个模块对象，然后根据路径载入并编译，对于不同的扩展名，有不同的载入方法
					<ul>
						<li>
							.js文件。通过fs模块同步读取文件后编译执行
						</li>
						<li>
							.node。c/c++扩展编写的文件，通过dlopen方法加载最后编译生成的文件
						</li>
						<li>
							.json.通过fs模块读取文件，用JSON.parse()解析返回结果。
						</li>
						<li>
							每一个编译成功的模块都会讲其文件路径作为索引缓存在module_cache对象上，以提高二次引入的性能。
						</li>
					</ul>
				</li>
			</ul>
		</li>
		<li>
			模块分类
			<ul>
				<li>
					核心模块：node提供
				</li>
				<li>
					文件模块：用户自己编写
				</li>
			</ul>
		</li>
		<li>
			npm包标准
			<ul>
				<li>
					bin:二进制可执行文件
				</li>
				<li>
					lib:用于存放js代码的文件
				</li>
				<li>
					doc:文档的目录
				</li>
				<li>
					test:单元测试用例的代码
				</li>
			</ul>
		</li>
	</ul>
</body>
</html>