<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>使用事件发射器模式简化事件绑定</title>
</head>
<body>
	<ul>
		<li>
			事件发射器：在node中，很多对象都可以发射事件。程序员可以订阅感兴趣的事件，并将回调函数绑定到相关的事件上，每当事件发射器发射事件时，对应的回调函数就会被调用
		</li>
		<li>
			events模块比前端浏览器中的大量DOM事件简单，没有冒泡，没有preventDefault,stopPropagation()
		</li>
		<li>
			事件发布，订阅模式常常用来解耦业务逻辑，事件发布者无需关注订阅的侦听器如何实现业务逻辑，只需要注意组价的接口设计即可。
		</li>
		<li>
			利用高阶函数的优势，诊听器作为回调函数可以随意添加和删除，很方便的处理业务逻辑
		</li>
		<li>
			利用事件队列解决雪崩问题
		</li>
		<li>
			根据事件类型，事件发射器负责按照事件所绑定的监视器的注册顺序依次调用事件监听器。这将意味着
			<ul>
				<li>
					某个事件监听器也许并不会在事件发射之后立即被调用，也许在他之前会有别的事件监听器被调用
				</li>
				<li>
					异常被抛出到堆栈并不正常，它通常是由代码中的错误引起的，当事件被发射时，如果其中某个事件监听器在被调用时抛出错误，可能会导致一些事件监听器永远不会被调用
				</li>
			</ul>
		</li>
	</ul>
	<h1>EventEmitter类方法</h1>
	<ul>
	    <li>对指定事件绑定事件处理函数时</li>
		<li>
			addListener(event,listener)
		</li>
		<li>
			on(上一个方法的别称)
		</li>
		<li>
			once
		</li>
		<li>
			removeListener(event,listener)
		</li>
		<li>
			removeAllListener([event])
		</li>
		<li>
			listeners(event):获取指定事件的所有处理函数。
		</li>
		<li>
			emit(event,[]):手工触发指定事件
		</li>
		<li>
			如何注册事件呢？
		</li>
		<li>
			也是直接注册，但是触发需要用到emit()来触发。那就证明他是没办法和外面的事件有关系的。只能自己触发事件。。。。
		</li>
		<li>
			接下来才是需要注意的：EventEmitter;
		</li>
		<li>
			EventEmitter.listenerCount(server,'request'):获取某个对象的指定事件的处理函数的数量。
		</li>
		<li>
			任何时候，当继承了EventEmitter类的子类实例对象绑定和解绑处理函数的时候，都会被检测到。
		</li>
		<li>
			server.on('newListener',(e,f)=>{console.log('正在绑定函数')})
		</li>
		<li>
			server.on('removerListener',(e,f)=>{console.loh('解绑一个函数')})
		</li>
	</ul>
</body>
</html>