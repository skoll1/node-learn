<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
		<p>在node中，可以使用zlib模块进行压缩以及解压缩的处理，在该模块内部使用zlib类库实现这些处理</p>
		<ul>
			<li>
				zlib.createGzip()
			</li>
			<li>
				zlib.createGunzip()
			</li>
			<li>
				zlib.createDeflateRaw():使用deflate算法对数据进行压缩处理，在压缩数据中不添加zlib头
			</li>
			<li>
				zlib.createInflateRaw():返回他的解压缩对象。
			</li>
			<li>
				zlib.createDeflate():创建并发布会一个defalte对象，该对象使用deflate算法对数据
			</li>
			<li>
				两个的区别就是返回的对象不一样。
			</li>
			<li>
				zlib.createIndeflate():返回deflate的解压缩对象。
			</li>
			<li>
				zlib.createUnzip():自动判断选择解压缩算法。
			</li>
		</ul>
		<h1>options参数</h1>
		<ul>
			<li>
				flush:用于设定或读取压缩方法及状态。参数完全记不住
			</li>
			<li>
				chunkSize:用于设定将数据分块时的每个块的大小，单位是字节
			</li>
			<li>
				windowBits:用于设定压缩窗口的大小，值越大，压缩效果越好，内存消耗越高。
			</li>
			<li>
				level:指定压缩级别：6.指定压缩级别。
			</li>
			<li>
				memLevel：在压缩时为压缩程序分配多少内存（1-9）.
			</li>
			<li>
				strategy:调整压缩算法。
			</li>
		</ul>
		<h1>http中使用压缩</h1>
		<ul>
			<li>
				客户端请求头中accept-encoding字段指定服务端使用的压缩算法，content-encoding声明服务器端响应数据的压缩算法。
			</li>
			<li>
				具体流程：http服务器接受到客户端请求，获取客户端请求头中的accpet-encoding字段，如果字段值包含‘deflate’字符串，创建delate对象并使用该对象压缩应用程序根目录下的test.text文件，在服务端响应头中将content-encoding字段值指定为‘deflate’，然后将压缩后的数据返回给客户端，如果什么都不包含，那就直接返回文件夹。
			</li>
		</ul>
		<h1>可以不加options，并且还有回调函数的方法。</h1>
		<ul>
			<li>
				zlib.gzip(data,cb);
			</li>
			<li>zlib.gunzip(data,cb)</li>
			<li>zlib.deflate(data,cb)</li>
			<li>zlib.inflate()</li>
			<li>zlib.deflateRaw()</li>
			<li>zlib.unzip()</li>
			<li>
				zlib.infalteRew()
			</li>
		</ul>
</body>
</html>